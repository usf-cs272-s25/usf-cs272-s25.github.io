---
title: Course Intro
layout: raw
---

<br><br>
# Welcome to CS 272 Software Development

<img src="https://go.dev/blog/gopher/gopher.png"/>
---

# Course Introduction 1

- Inspired by Prof. Engle's successful course
    - Web crawling, indexing, searching
    - Code-review centric
    - Similar policies 

---

# Course Introduction 2

- But not exactly the same
    - Implementation language: Java -> Go
    - Database: SQL is required
    - Emphasis on Software Engineering habits

---

# Instructor Introduction

- Professional Background
- Teaching Experience

---

# Class Introductions

- Icebreaker
    - Your name (nickname?)
    - Hometown
    - Ask me about...

---

# Syllabus Review

- Noteworthy Policies
    - Letter Grade Scale
    - Late Work
    - Original Work

---

# Course Deliverables 1

- Attendance
- Weekly assignments
    - Low-stakes labs build into higher-stakes projects
- Regular code reviews
- Two exams: midterm around Fall Break, final exam

---

# Course Deliverables 2

- 5-6 significant projects
    - Learning Go
    - Indexing Web Sites
    - Persisting the index in a relational DB
    - Concurrency
    - Using Large Language Models ("AI") for searching

---

# Expectations

- The workload will be significant but doable
- Attendance is strongly recommended
- Small sections: more interaction, questions
- Review CampusWire Etiquette
- There are no dumb questions
<br><br>
- Pro Tip: Your future manager expects you to manage your productivity <!-- .element: class="fragment" -->

---

<br><br>
# Why Go?

---

# C (1970s)

### Pro
+ Source code is portable across processor architectures (unlike assembly language)
+ Compiles to machine code (high performance)

--- 

# C (1970s)

### Con
- C does not help large teams writing large projects
- C is not memory-safe (`NULL` pointers, `malloc/free` bugs, buffer overflow, ugh!)
- C is not strongly-typed

---

# C++ (1980s)

### Pro
+ C++ is a super-set of C and adds OOP classes, inheritance, etc.
+ C++ is strongly-typed

---

# C++ (1980s)

### Con
- Still not memory-safe, but reference-counting is common
- "Modern C++" is a large, complex language

--- 

# Java (1990s)

### Pro
- Object-Oriented
- Suitable for large teams/projects
- Performance is acceptable for some applications
- Java is memory-safe (GC, immutable strings)

---

# Java (1990s)

### Con
- Large, complex language
- GC takes too much time for some applications

---

# Go (2010s)

### Pro

- Compiles to machine code
- Small, simple language, especially for concurrency
- OO, but simpler than C++ or Java
- Memory-safe (GC and immutable strings)

---

# Go (2010s)

### Con
- Newer language, not as widely deployed as C/C++ and Java
- GC takes too much time for some applications

---

# Rust

### Pro
- Compiles to machine code
- Memory-safe, but no Garbage Collector
- Compiler tracks all memory references and "borrows" a pointer value when needed
- Probably the future of "systems" programming

---

# Moral of the story

1. Memory safety will be a baseline requirement <!-- .element: class="fragment" -->
1. Languages are specialized to categories of applications <!-- .element: class="fragment" -->
1. Pro tip: Use the right tool for the job <!-- .element: class="fragment" -->